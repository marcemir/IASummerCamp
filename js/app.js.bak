// HOLA

console.log('app.js cargado correctamente');

// Elementos del DOM
let splashScreen, userTypeScreen, authScreen, registerScreen, interviewScreen, appContainer, 
    loginForm, registerForm, interviewForm, emailInput, passwordInput, togglePassword, rememberMe, 
    showRegister, showLogin, messagesContainer, interviewMessages, messageForm, messageInput, 
    sendButton, recordButton, stopRecordButton, themeToggle, userEmail, logoutButton, studentBtn, 
    teacherBtn, interviewAnswer, startChatBtn;

// Elementos del menú desplegable
let menuButton, dropdownMenu, uploadMaterialBtn, uploadPhotoBtn, myDataBtn;

// Elementos para carga de archivos
let uploadButton, uploadModal, closeModal, dropArea, fileSelector, fileInfo, cancelUpload, confirmUpload, uploadProgress, progressBar, progressText;

// Almacenamiento de archivos subidos
let uploadedFiles = [];

function getElement(id) {
    const element = document.getElementById(id);
    if (!element) {
        console.error(`No se encontró el elemento con ID: ${id}`);
    }
    return element;
}

function initializeDOMElements() {
    console.log('Inicializando elementos del DOM...');
    
    // Pantallas
    splashScreen = getElement('splash-screen');
    userTypeScreen = getElement('user-type-screen');
    authScreen = getElement('auth-screen');
    appContainer = getElement('app-container');
    
    
    // Pantallas adicionales
    registerScreen = getElement('register-screen');
    interviewScreen = getElement('interview-screen');
    
    // Elementos del chat
    messagesContainer = document.getElementById('messages');
    if (!messagesContainer) {
        console.error('No se pudo encontrar el contenedor de mensajes');
        // Intentar crear el contenedor si no existe
        const chatContainer = document.querySelector('.chat-container');
        if (chatContainer) {
            messagesContainer = document.createElement('div');
            messagesContainer.id = 'messages';
            messagesContainer.className = 'messages';
            chatContainer.insertBefore(messagesContainer, document.querySelector('.input-container'));
            console.log('Contenedor de mensajes creado manualmente');
        }
    }
    
    interviewMessages = getElement('interview-messages');
    messageForm = document.getElementById('message-form');
    
    // Asegurarse de que el formulario de mensajes exista
    if (!messageForm) {
        console.error('No se pudo encontrar el formulario de mensajes');
        const inputContainer = document.querySelector('.input-container');
        if (inputContainer) {
            messageForm = document.createElement('form');
            messageForm.id = 'message-form';
            messageForm.className = 'message-form';
            messageForm.innerHTML = `
                <input type="text" id="message-input" class="message-input" placeholder="Escribe tu mensaje..." autocomplete="off" required>
                <button type="submit" id="send-button" class="send-button" title="Enviar mensaje">
                    <i class="fas fa-paper-plane"></i>
                </button>
            `;
            inputContainer.appendChild(messageForm);
            console.log('Formulario de mensajes creado manualmente');
        }
    }
    
    interviewForm = getElement('interview-form');
    messageInput = document.getElementById('message-input');
    
    // Asegurarse de que el campo de entrada de mensaje exista
    if (!messageInput && messageForm) {
        messageInput = document.createElement('input');
        messageInput.type = 'text';
        messageInput.id = 'message-input';
        messageInput.className = 'message-input';
        messageInput.placeholder = 'Escribe tu mensaje...';
        messageInput.autocomplete = 'off';
        messageInput.required = true;
        messageForm.insertBefore(messageInput, messageForm.firstChild);
        console.log('Campo de entrada de mensaje creado manualmente');
    }
    
    interviewAnswer = getElement('interview-answer');
    sendButton = document.getElementById('send-button');
    
    // Asegurarse de que el botón de envío exista
    if (!sendButton && messageForm) {
        sendButton = document.createElement('button');
        sendButton.type = 'submit';
        sendButton.id = 'send-button';
        sendButton.className = 'send-button';
        sendButton.title = 'Enviar mensaje';
        sendButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
        messageForm.appendChild(sendButton);
        console.log('Botón de envío creado manualmente');
    }
    
    recordButton = getElement('record-button');
    stopRecordButton = getElement('stop-record-button');
    
    // Configurar botones de grabación
    if (recordButton) {
        recordButton.title = 'Grabar mensaje de voz';
        recordButton.addEventListener('click', startVoiceRecognition);
    }
    if (stopRecordButton) {
        stopRecordButton.title = 'Detener grabación';
        stopRecordButton.addEventListener('click', stopVoiceRecognition);
        stopRecordButton.style.display = 'none';  // Ocultar inicialmente
    }
    
    console.log('Elementos del DOM inicializados correctamente', {
        messagesContainer: !!messagesContainer,
        messageForm: !!messageForm,
        messageInput: !!messageInput,
        sendButton: !!sendButton
    });
    
    // Elementos de autenticación
    loginForm = getElement('login-form');
    emailInput = getElement('email');
    passwordInput = getElement('password');
    togglePassword = getElement('toggle-password');
    rememberMe = getElement('remember-me');
    showRegister = getElement('show-register');
    
    // Botones de selección de tipo de usuario
    studentBtn = getElement('student-btn');
    teacherBtn = getElement('teacher-btn');
    
    themeToggle = getElement('theme-toggle');
    userEmail = getElement('user-email');
    logoutButton = getElement('logout-button');
    showLogin = getElement('show-login');
    startChatBtn = getElement('start-chat');
    
    // Elementos del menú desplegable
    menuButton = getElement('menu-button');
    dropdownMenu = getElement('dropdown-menu');
    uploadMaterialBtn = getElement('upload-material');
    uploadPhotoBtn = getElement('upload-photo');
    myDataBtn = getElement('my-data');
    
    // Elementos para carga de archivos
    uploadButton = getElement('upload-button');
    uploadModal = getElement('upload-modal');
    closeModal = document.querySelector('.close-modal');
    dropArea = getElement('drop-area');
    fileSelector = getElement('file-selector');
    fileInfo = getElement('file-info');
    cancelUpload = getElement('cancel-upload');
    confirmUpload = getElement('confirm-upload');
    uploadProgress = getElement('upload-progress');
    progressBar = getElement('progress-bar');
    progressText = getElement('progress-text');
    
    // Verificar elementos críticos
    if (!splashScreen || !authScreen || !appContainer) {
        console.error('Error: No se pudieron cargar los elementos principales del DOM');
        return false;
    }
    
    console.log('Elementos del DOM inicializados correctamente');
    return true;
}

// Estado de la aplicación
let isDarkMode = localStorage.getItem('darkMode') === 'true';

// Estado de la entrevista
let currentInterviewStep = 0;
const interviewQuestions = [
    "¿Cuál es tu nombre?",
    "¿Cuáles son tus intereses principales?",
    "¿Qué te gustaría aprender con SocratIA?",
    "¿Tienes algún conocimiento previo sobre este tema?",
    "¿Cuánto tiempo puedes dedicar al aprendizaje semanalmente?"
];

// Variables para grabación de voz
let recognition = null;
let isListening = false;

// Iniciar reconocimiento de voz
function startVoiceRecognition() {
    console.log('Iniciando reconocimiento de voz...');
    if (isListening) {
        console.log('El reconocimiento de voz ya está activo');
        return;
    }
    
    try {
        recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
        recognition.lang = 'es-ES';
        recognition.continuous = false;
        recognition.interimResults = false;
        
        recognition.onstart = () => {
            console.log('Reconocimiento de voz iniciado');
            isListening = true;
            updateRecordingUI(true);
        };
        
        recognition.onresult = async (event) => {
            console.log('Resultado de reconocimiento de voz recibido');
            if (event.results && event.results[0] && event.results[0][0]) {
                const transcript = event.results[0][0].transcript;
                console.log('Transcripción:', transcript);
                if (transcript.trim()) {
                    await handleRecordedAudio(transcript);
                }
            }
        };
        
        recognition.onerror = (event) => {
            console.error('Error en reconocimiento de voz:', event.error);
            isListening = false;
            updateRecordingUI(false);
            // Mostrar mensaje de error al usuario
            addMessage('assistant', 'Error al acceder al micrófono. Por favor, asegúrate de que la aplicación tenga los permisos necesarios.');
        };
        
        recognition.onend = () => {
            console.log('Reconocimiento de voz finalizado. Estado isListening:', isListening);
            if (isListening) { // Solo actualizar si no fue detenido manualmente
                isListening = false;
                updateRecordingUI(false);
            }
        };
        
        console.log('Iniciando reconocimiento...');
        recognition.start();
    } catch (error) {
        console.error('Error al iniciar el reconocimiento de voz:', error);
        isListening = false;
        updateRecordingUI(false);
        // Mostrar mensaje de error al usuario
        addMessage('assistant', 'No se pudo iniciar el reconocimiento de voz. Por favor, inténtalo de nuevo.');
    }
}

// Detener reconocimiento de voz
function stopVoiceRecognition() {
    if (recognition && isListening) {
        isListening = false; // Marcar como detenido antes de detener para evitar conflictos
        try {
            recognition.stop();
        } catch (e) {
            console.error('Error al detener el reconocimiento:', e);
        }
        updateRecordingUI(false);
    }
}

// Actualizar interfaz de grabación
function updateRecordingUI(recording) {
    console.log('Actualizando UI de grabación. Grabando:', recording);
    if (recordButton) {
        if (recording) {
            recordButton.classList.add('hidden');
        } else {
            recordButton.classList.remove('hidden');
        }
        console.log('Botón grabar - clase hidden:', recordButton.classList.contains('hidden'));
    }
    if (stopRecordButton) {
        if (recording) {
            stopRecordButton.classList.remove('hidden');
        } else {
            stopRecordButton.classList.add('hidden');
        }
        console.log('Botón detener - clase hidden:', stopRecordButton.classList.contains('hidden'));
    }
}

// Inicializar el usuario y token desde el almacenamiento al cargar la página
let currentUser = (() => {
    try {
        const storedUser = localStorage.getItem('currentUser') || sessionStorage.getItem('currentUser');
        return storedUser ? JSON.parse(storedUser) : null;
    } catch (e) {
        console.error('Error al cargar el usuario del almacenamiento:', e);
        return null;
    }
})();

let authToken = localStorage.getItem('authToken') || sessionStorage.getItem('authToken') || null;
let userType = currentUser?.role || null; // 'student' o 'teacher'

// Mostrar pantalla de error crítica
function showErrorScreen(message) {
    // Ocultar splash si está visible
    if (splashScreen) {
        splashScreen.style.display = 'none';
        splashScreen.classList.add('hidden');
    }
    // Crear o reutilizar un div de error
    let errorDiv = document.getElementById('critical-error-screen');
    if (!errorDiv) {
        errorDiv = document.createElement('div');
        errorDiv.id = 'critical-error-screen';
        errorDiv.style.position = 'fixed';
        errorDiv.style.top = '0';
        errorDiv.style.left = '0';
        errorDiv.style.width = '100%';
        errorDiv.style.height = '100%';
        errorDiv.style.background = '#fff';
        errorDiv.style.zIndex = '99999';
        errorDiv.style.display = 'flex';
        errorDiv.style.flexDirection = 'column';
        errorDiv.style.justifyContent = 'center';
        errorDiv.style.alignItems = 'center';
        errorDiv.style.fontFamily = 'Poppins, Arial, sans-serif';
        errorDiv.style.color = '#b91c1c';
        errorDiv.style.fontSize = '1.3rem';
        errorDiv.innerHTML = '';
        document.body.appendChild(errorDiv);
    }
    errorDiv.innerHTML = `
        <div style="max-width: 500px; padding: 30px; border-radius: 12px; background: #fee2e2; box-shadow: 0 2px 16px #0002; text-align: center;">
            <h2 style="margin-bottom: 20px;">¡Ups! Ocurrió un error</h2>
            <p style="margin-bottom: 20px;">${message || 'No se pudo cargar la aplicación. Por favor, recarga la página.'}</p>
            <button onclick="window.location.reload()" style="padding: 10px 28px; border: none; border-radius: 6px; background: #b91c1c; color: #fff; font-size: 1.1rem; cursor: pointer;">Recargar página</button>
        </div>
    `;
}

// Inicialización
async function init() {
    try {
        console.log('Inicializando la aplicación...');

        // 1. Inicializar elementos del DOM
        if (!initializeDOMElements()) {
            console.error('Error al inicializar elementos del DOM');
            showErrorScreen('Error al cargar la aplicación. Por favor, recarga la página.');
            return;
        }

        // 2. Configurar eventos
        setupEventListeners();

        // 3. Configurar tema
        updateTheme();

        // 4. Verificar autenticación
        if (isAuthenticated()) {
            console.log('Usuario autenticado:', currentUser);

            // Mostrar pantalla de inicio por un momento
            showSplashScreen();

            // Pequeño retraso para mostrar el splash screen
            setTimeout(async () => {
                try {
                    await hideSplashScreen();
                    showApp();
                    loadMessages();
                } catch (e) {
                    console.error('Error tras splashScreen:', e);
                    showErrorScreen('Error tras cargar el logo. Por favor, recarga la página.');
                }
            }, 1000);
        } else {
            // 5. Mostrar pantalla de inicio
            showSplashScreen();

            // Después de 1.5 segundos, mostrar la pantalla de selección de usuario
            setTimeout(async () => {
                try {
                    await hideSplashScreen();
                    showUserTypeScreen();
                } catch (e) {
                    console.error('Error tras splashScreen (no autenticado):', e);
                    showErrorScreen('Error tras cargar el logo. Por favor, recarga la página.');
                }
            }, 1500);
        }

        console.log('Aplicación inicializada correctamente');
    } catch (error) {
        console.error('Error en la inicialización:', error);
        showErrorScreen('Error crítico al cargar la aplicación. Por favor, recarga la página.');
    }
}

// Flujo de la aplicación
async function startAppFlow() {
    // Iniciar la entrevista si es un nuevo usuario
    const newUser = localStorage.getItem('newUser') === 'true';
    if (newUser) {
        startInterview();
        return;
    }
    try {
        console.log('Iniciando flujo de la aplicación...');
        
        // Verificar que los elementos críticos del DOM estén disponibles
        if (!splashScreen || !authScreen || !appContainer) {
            console.error('Error: Elementos críticos del DOM no están disponibles');
            return;
        }
        
        // Mostrar pantalla de inicio
        showSplashScreen();
        
        // Verificar si hay una sesión activa
        if (isAuthenticated()) {
            console.log('Sesión activa encontrada, redirigiendo...');
            // Pequeño retraso para mostrar la animación de carga
            setTimeout(() => {
                hideSplashScreen();
                if (currentUser.role === 'teacher') {
                    window.location.href = 'construction.html';
                } else {
                    showApp();
                    loadMessages();
                }
            }, 1500);
            return;
        }
        
        // Si no hay sesión activa, continuar con el flujo normal
        console.log('No hay sesión activa, mostrando pantalla de selección de usuario...');
        setTimeout(() => {
            try {
                hideSplashScreen();
                showUserTypeScreen();
            } catch (error) {
                console.error('Error en el flujo de autenticación:', error);
                showAuthScreen();
            }
        }, 1500); // 1.5 segundos para la animación de carga
    } catch (error) {
        console.error('Error crítico en startAppFlow:', error);
        // Mostrar un mensaje de error genérico
        if (document.body) {
            document.body.innerHTML = `
                <div style="padding: 20px; font-family: Arial, sans-serif; text-align: center;">
                    <h2>¡Ups! Algo salió mal</h2>
                    <p>No se pudo cargar la aplicación correctamente.</p>
                    <p>Por favor, recarga la página o inténtalo de nuevo.</p>
                    <button onclick="window.location.reload()" style="padding: 10px 20px; margin-top: 20px; cursor: pointer;">
                        Recargar Página
                    </button>
                </div>
            `;
        }
    }
}

// Verificar si el usuario está autenticado
function isAuthenticated() {
    try {
        // Verificar si ya tenemos el usuario en memoria
        if (currentUser && authToken) {
            console.log('Usuario ya está en memoria:', currentUser.email);
            return true;
        }
        
        // Buscar en localStorage y sessionStorage
        const storageTypes = [localStorage, sessionStorage];
        
        for (const storage of storageTypes) {
            try {
                const storedUser = storage.getItem('currentUser');
                const storedToken = storage.getItem('authToken');
                
                if (storedUser && storedToken) {
                    const user = JSON.parse(storedUser);
                    
                    // Validar estructura del usuario
                    if (user && typeof user === 'object' && user.id && user.email) {
                        console.log('Usuario autenticado encontrado en', storage === localStorage ? 'localStorage' : 'sessionStorage');
                        
                        // Actualizar estado global
                        currentUser = user;
                        authToken = storedToken;
                        userType = user.role || 'student';
                        
                        // Si el token está en sessionStorage, moverlo a localStorage si es necesario
                        if (storage === sessionStorage && rememberMe?.checked) {
                            localStorage.setItem('currentUser', storedUser);
                            localStorage.setItem('authToken', storedToken);
                            sessionStorage.removeItem('currentUser');
                            sessionStorage.removeItem('authToken');
                            console.log('Sesión movida a localStorage');
                        }
                        
                        return true;
                    } else {
                        console.warn('Datos de usuario inválidos en el almacenamiento');
                        storage.removeItem('currentUser');
                        storage.removeItem('authToken');
                    }
                }
            } catch (e) {
                console.error('Error al verificar el almacenamiento:', e);
                // Limpiar datos corruptos
                storage.removeItem('currentUser');
                storage.removeItem('authToken');
            }
        }
        
        console.log('No se encontró una sesión activa');
        return false;
    } catch (error) {
        console.error('Error al verificar la autenticación:', error);
        return false;
    }
}

// Función para mostrar errores de validación
function showError(input, message) {
    const formGroup = input.closest('.form-group');
    const errorElement = formGroup.querySelector('.error-message');
    
    formGroup.classList.add('error');
    if (errorElement) {
        errorElement.textContent = message;
        errorElement.style.display = 'block';
    }
    
    // Enfocar el campo con error
    input.focus();
    return false;
}

// Función para limpiar errores de validación
function clearError(input) {
    const formGroup = input.closest('.form-group');
    if (formGroup) {
        formGroup.classList.remove('error');
        const errorElement = formGroup.querySelector('.error-message');
        if (errorElement) {
            errorElement.style.display = 'none';
        }
    }
}

// Validar un campo individual
function validateField(input) {
    const value = input.value.trim();
    const type = input.getAttribute('data-validate');
    
    // Limpiar errores previos
    clearError(input);
    
    // Validar campo requerido
    if (input.required && !value) {
        return showError(input, 'Este campo es obligatorio');
    }
    
    // Validaciones específicas por tipo
    if (type === 'email' && value) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(value)) {
            return showError(input, 'Por favor, introduce un correo electrónico válido');
        }
    }
    
    if (type === 'password' && value) {
        if (value.length < 6) {
            return showError(input, 'La contraseña debe tener al menos 6 caracteres');
        }
    }
    
    return true;
}

// Validar todo el formulario
function validateForm(form) {
    let isValid = true;
    const inputs = form.querySelectorAll('input[data-validate]');
    
    inputs.forEach(input => {
        if (!validateField(input)) {
            isValid = false;
        }
    });
    
    return isValid;
}

// Manejar inicio de sesión (versión fake para MVP)
function handleLogin(email, password, remember) {
    console.log(`Intento de inicio de sesión con email: ${email}`);
    
    try {
        // Limpiar errores previos
        if (emailInput) clearError(emailInput);
        if (passwordInput) clearError(passwordInput);
        
        // Validar campos
        let isValid = true;
        
        // Validar email
        if (!email) {
            showError(emailInput, 'El correo electrónico es obligatorio');
            isValid = false;
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
            showError(emailInput, 'Por favor, introduce un correo electrónico válido');
            isValid = false;
        }
        
        // Validar contraseña
        if (!password) {
            showError(passwordInput, 'La contraseña es obligatoria');
            isValid = false;
        } else if (password.length < 6) {
            showError(passwordInput, 'La contraseña debe tener al menos 6 caracteres');
            isValid = false;
        }
        
        if (!isValid) {
            return false;
        }
        
        // Mostrar indicador de carga
        const loginButton = document.querySelector('#login-form button[type="submit"]');
        const originalButtonText = loginButton ? loginButton.innerHTML : '';
        if (loginButton) {
            loginButton.disabled = true;
            loginButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Iniciando sesión...';
        }
        
        // Simular una pequeña demora para la autenticación
        setTimeout(() => {
            try {
                // Asegurarse de que userType esté definido
                const userRole = userType || 'student';
                
                // Obtener datos existentes del usuario si existen
                const existingUser = JSON.parse(localStorage.getItem('currentUser') || sessionStorage.getItem('currentUser') || '{}');
                
                // Datos de usuario, conservando los existentes
                const userData = {
                    ...existingUser, // Mantener datos existentes (incluyendo la entrevista)
                    id: existingUser.id || 'user-' + Math.random().toString(36).substr(2, 9),
                    email: email.trim().toLowerCase(),
                    name: existingUser.preferred_name || email.split('@')[0].charAt(0).toUpperCase() + email.split('@')[0].slice(1), // Usar preferred_name si existe
                    role: userRole,
                    lastLogin: new Date().toISOString()
                };
                
                console.log('Datos del usuario al iniciar sesión:', userData);
                
                // Actualizar userType global
                userType = userRole;
                
                // Determinar el almacenamiento a usar
                const storage = remember ? localStorage : sessionStorage;
                const otherStorage = remember ? sessionStorage : localStorage;
                
                try {
                    // Guardar en el almacenamiento seleccionado
                    storage.setItem('currentUser', JSON.stringify(userData));
                    storage.setItem('authToken', 'fake-jwt-token-' + Date.now());
                    
                    // Limpiar el otro almacenamiento para evitar conflictos
                    otherStorage.removeItem('currentUser');
                    otherStorage.removeItem('authToken');
                    
                    console.log(`Sesión guardada en ${remember ? 'localStorage' : 'sessionStorage'}`);
                    
                    // Actualizar el estado global
                    currentUser = userData;
                    authToken = storage.getItem('authToken');
                    console.log('Usuario autenticado:', currentUser);
                    
                    // Actualizar la interfaz de usuario
                    updateUIAfterLogin();
                    
                    // Redirigir o mostrar la aplicación después de un breve retraso
                    setTimeout(() => {
                        // Verificar si es un profesor para redirigir a la página de construcción
                        if (currentUser.role === 'teacher') {
                            window.location.href = 'construction.html';
                            return;
                        }
                        
                        // Si es estudiante, mostrar la aplicación principal
                        showApp();
                        
                        // Cargar mensajes existentes
                        loadMessages();
                        
                        // Mostrar mensaje de bienvenida si no hay mensajes
                        if (messagesContainer && messagesContainer.children.length === 0) {
                            addMessage('assistant', `¡Bienvenido a SocratIA, ${currentUser.name}! ¿En qué puedo ayudarte hoy?`);
                        }
                        
                        // Hacer foco en el campo de entrada de mensajes
                        if (messageInput) {
                            messageInput.focus();
                        }
                    }, 350);
                    
                    return true;
                } catch (error) {
                    console.error('Error durante el proceso de autenticación:', error);
                    // Mostrar mensaje de error al usuario
                    alert('Error al iniciar sesión. Por favor, inténtalo de nuevo.');
                    return false;
                }
            } catch (error) {
                console.error('Error en handleLogin:', error);
                alert('Se produjo un error al intentar iniciar sesión. Por favor, recarga la página e inténtalo de nuevo.');
                return false;
            }
        }, 500); // Simular tiempo de autenticación
        
        return true; // Devolver true inmediatamente mientras se procesa la autenticación
    } catch (error) {
        console.error('Error en handleLogin:', error);
        alert('Se produjo un error al intentar iniciar sesión. Por favor, recarga la página e inténtalo de nuevo.');
        return false;
    }
}

// Actualizar la interfaz de usuario después del inicio de sesión
function updateUIAfterLogin() {
    try {
        // Restaurar el botón de inicio de sesión
        const loginButton = document.querySelector('#login-form button[type="submit"]');
        if (loginButton) {
            loginButton.disabled = false;
            loginButton.innerHTML = 'Iniciar sesión';
        }
        
        // Actualizar el correo del usuario en la interfaz si existe el elemento
        if (userEmail) {
            userEmail.textContent = currentUser.email;
        }
        
        // Actualizar el menú de usuario si existe
        // Mantenemos el texto 'Menú' en lugar del nombre del usuario
        if (menuButton) {
            const menuText = menuButton.querySelector('.menu-text');
            if (menuText) {
                menuText.textContent = 'Menú';
            }
        }
        
        // Ocultar pantalla de autenticación con transición
        hideAuthScreen();
        
        // Mostrar notificación de éxito
        if (typeof showNotification === 'function') {
            showNotification(`¡Bienvenido/a de nuevo, ${currentUser.name}!`, 'success');
        } else {
            console.log(`¡Bienvenido/a de nuevo, ${currentUser.name}!`);
        }
    } catch (error) {
        console.error('Error al actualizar la interfaz después del inicio de sesión:', error);
    }
}

// Manejar cierre de sesión
function handleLogout() {
    try {
        console.log('Cerrando sesión...');
        
        // Guardar el correo del usuario para futura referencia
        const userEmail = currentUser ? currentUser.email : null;
        
        // Limpiar el estado de la aplicación
        currentUser = null;
        authToken = null;
        
        // Limpiar el almacenamiento local y de sesión
        localStorage.removeItem('currentUser');
        localStorage.removeItem('authToken');
        sessionStorage.removeItem('currentUser');
        sessionStorage.removeItem('authToken');
        
        console.log('Datos de sesión eliminados');
        
        // Si estamos en la página de construcción, redirigir a index.html
        if (window.location.pathname.endsWith('construction.html') || window.location.pathname.endsWith('index.html')) {
            window.location.href = 'index.html';
            return;
        }
        
        // Ocultar la aplicación y mostrar la pantalla de autenticación
        hideApp();
        
        // Limpiar el formulario de inicio de sesión si existe
        if (loginForm) {
            loginForm.reset();
            // Restaurar el correo electrónico si existe
            if (userEmail && emailInput) {
                emailInput.value = userEmail;
                // Marcar el checkbox de recordar usuario
                if (rememberMe) {
                    rememberMe.checked = true;
                }
            }
        }
        
        // Mostrar la pantalla de selección de tipo de usuario
        showUserTypeScreen();
        
        console.log('Sesión cerrada correctamente');
        return true;
    } catch (error) {
        console.error('Error al cerrar sesión:', error);
        // Intentar redirigir a la pantalla de autenticación de todos modos
        if (authScreen) {
            showAuthScreen();
        }
        return false;
    }
}

// Mostrar/ocultar pantallas
function showUserTypeScreen() {
    try {
        console.log('Mostrando pantalla de selección de tipo de usuario');
        if (userTypeScreen) {
            userTypeScreen.classList.remove('hidden');
        } else {
            console.error('Error: No se pudo encontrar el elemento userTypeScreen');
        }
    } catch (error) {
        console.error('Error al mostrar la pantalla de selección de tipo de usuario:', error);
    }
}

function hideUserTypeScreen() {
    try {
        if (userTypeScreen) {
            userTypeScreen.classList.add('hidden');
        }
    } catch (error) {
        console.error('Error al ocultar la pantalla de selección de tipo de usuario:', error);
    }
}

function showSplashScreen() {
    console.log('Mostrando pantalla de inicio...');
    
    // Asegurarse de que el elemento existe
    if (!splashScreen) {
        console.error('No se pudo encontrar el elemento splashScreen');
        return false;
    }
    
    try {
        // Asegurarse de que no esté oculto por CSS
        splashScreen.style.display = 'flex';
        splashScreen.style.opacity = '0';
        splashScreen.classList.remove('hidden');
        
        // Forzar un reflow para que la transición funcione
        void splashScreen.offsetHeight;
        
        // Aplicar la opacidad con transición
        setTimeout(() => {
            splashScreen.style.opacity = '1';
        }, 10);
        
        console.log('Pantalla de inicio mostrada correctamente');
        return true;
    } catch (error) {
        console.error('Error al mostrar la pantalla de inicio:', error);
        return false;
    }
}

function hideSplashScreen() {
    console.log('Ocultando pantalla de inicio...');
    
    // Asegurarse de que el elemento existe
    if (!splashScreen) {
        console.error('No se pudo encontrar el elemento splashScreen');
        return false;
    }
    
    try {
        // Iniciar la transición de opacidad
        splashScreen.style.opacity = '0';
        
        // Esperar a que termine la transición antes de ocultar el elemento
        return new Promise((resolve) => {
            setTimeout(() => {
                try {
                    splashScreen.style.display = 'none';
                    splashScreen.classList.add('hidden');
                    console.log('Pantalla de inicio ocultada correctamente');
                    resolve(true);
                } catch (error) {
                    console.error('Error al ocultar la pantalla de inicio:', error);
                    resolve(false);
                }
            }, 300); // Tiempo de la transición en ms
        });
    } catch (error) {
        console.error('Error al iniciar la transición de la pantalla de inicio:', error);
        return Promise.resolve(false);
    }
}

function showAuthScreen() {
    console.log('Mostrando pantalla de autenticación...');
    if (authScreen) {
        // Asegurarse de que no esté oculto por CSS
        authScreen.classList.remove('hidden');
        authScreen.style.display = 'flex';
        // Forzar un reflow para que la transición funcione
        void authScreen.offsetHeight;
        setTimeout(() => {
            authScreen.style.opacity = '1';
        }, 10);
    } else {
        console.error('No se pudo mostrar la pantalla de autenticación: elemento no encontrado');
    }
}

function hideAuthScreen() {
    console.log('Ocultando pantalla de autenticación...');
    if (authScreen) {
        authScreen.style.opacity = '0';
        setTimeout(() => {
            authScreen.style.display = 'none';
            authScreen.classList.add('hidden');
        }, 300);
    }
}

function showApp() {
    console.log('Mostrando aplicación...');
    
    // Ocultar todas las pantallas primero
    hideAllScreens();
    
    // Mostrar el contenedor principal de la aplicación
    if (appContainer) {
        // Asegurarse de que no esté oculto por CSS
        appContainer.classList.remove('hidden');
        appContainer.style.display = 'flex';
        
        // Forzar un reflow para que la transición funcione
        void appContainer.offsetHeight;
        
        // Aplicar la opacidad después de un pequeño retraso
        setTimeout(() => {
            appContainer.style.opacity = '1';
        }, 10);
        
        console.log('Aplicación mostrada correctamente');
    } else {
        console.error('No se pudo mostrar la aplicación: elemento app-container no encontrado');
    }
}

function hideApp() {
    console.log('Ocultando aplicación...');
    if (appContainer) {
        appContainer.style.opacity = '0';
        setTimeout(() => {
            appContainer.style.display = 'none';
            appContainer.classList.add('hidden');
        }, 300);
    }
}

// Configurar los event listeners
function setupEventListeners() {
    // Configurar el envío del formulario de mensajes
    if (messageForm) {
        messageForm.addEventListener('submit', function(e) {
            e.preventDefault();
            if (messageInput && messageInput.value.trim() !== '') {
                sendMessage();
            }
        });
    }

    // Configurar el evento de tecla Enter en el input
    const messageInput = document.getElementById('message-input');
    if (messageInput) {
        messageInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (this.value.trim() !== '') {
                    sendMessage();
                }
            }
        });
    }
    // Mostrar formulario de registro
    const showRegisterLink = document.getElementById('show-register');
    const showLoginLink = document.getElementById('show-login');
    
    if (showRegisterLink) {
        showRegisterLink.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('Mostrando pantalla de registro');
            if (authScreen) authScreen.classList.add('hidden');
            if (registerScreen) {
                registerScreen.classList.remove('hidden');
                // Enfocar el primer campo del formulario
                const nameInput = document.getElementById('register-name');
                if (nameInput) nameInput.focus();
            }
        });
    }
    
    if (showLoginLink) {
        showLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            console.log('Mostrando pantalla de login');
            if (registerScreen) registerScreen.classList.add('hidden');
            if (authScreen) {
                authScreen.classList.remove('hidden');
                // Enfocar el campo de email
                if (emailInput) emailInput.focus();
            }
        });
    }
    // Eventos de selección de tipo de usuario
    if (studentBtn) {
        studentBtn.addEventListener('click', () => {
            console.log('Seleccionado: Estudiante');
            userType = 'student';
            hideUserTypeScreen();
            showAuthScreen();
        });
    }
    
    if (teacherBtn) {
        teacherBtn.addEventListener('click', () => {
            console.log('Seleccionado: Profesor');
            userType = 'teacher';
            hideUserTypeScreen();
            showAuthScreen();
        });
    }
    
    // Eventos de autenticación
    if (loginForm) {
        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const email = emailInput.value.trim();
            const password = passwordInput.value;
            const remember = rememberMe.checked;
            
            if (email && password) {
                handleLogin(email, password, remember);
            }
        });
    }
    
    // Evento de registro
    const registerForm = document.getElementById('register-form');
    if (registerForm) {
        registerForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            console.log('Enviando formulario de registro');
            
            // Obtener los datos del formulario
            const name = document.getElementById('register-name').value.trim();
            const email = document.getElementById('register-email').value.trim();
            const password = document.getElementById('register-password').value;
            
            if (name && email && password) {
                try {
                    // Mostrar indicador de carga
                    const submitButton = registerForm.querySelector('button[type="submit"]');
                    const originalButtonText = submitButton.innerHTML;
                    submitButton.disabled = true;
                    submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Procesando...';
                    
                    // Simular un retraso para la operación asíncrona
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Guardar los datos del usuario en localStorage
                    const userData = {
                        name: name,
                        email: email,
                        role: 'student',
                        isAuthenticated: true,
                        hasCompletedInterview: false,
                        registrationDate: new Date().toISOString()
                    };
                    
                    localStorage.setItem('currentUser', JSON.stringify(userData));
                    console.log('Usuario registrado:', userData);
                    
                    // Ocultar pantalla de registro y mostrar pantalla de entrevista
                    if (registerScreen) registerScreen.classList.add('hidden');
                    if (interviewScreen) {
                        interviewScreen.classList.remove('hidden');
                        // Iniciar la entrevista
                        startInterview();
                    }
                } catch (error) {
                    console.error('Error en el registro:', error);
                    alert('Ocurrió un error al procesar el registro. Por favor, inténtalo de nuevo.');
                    submitButton.disabled = false;
                    submitButton.innerHTML = originalButtonText;
                }
            } else {
                alert('Por favor, completa todos los campos del formulario.');
            }
        });
    }
    
    // Mostrar/ocultar contraseña
    if (togglePassword && passwordInput) {
        togglePassword.addEventListener('click', () => {
            const type = passwordInput.type === 'password' ? 'text' : 'password';
            passwordInput.type = type;
            togglePassword.innerHTML = type === 'password' ? 
                '<i class="fas fa-eye"></i>' : 
                '<i class="fas fa-eye-slash"></i>';
        });
    }
    
    // Función para abrir/cerrar el menú
    function toggleMenu() {
        if (!menuButton || !dropdownMenu || !dropdownOverlay) return;
        
        const isExpanded = menuButton.getAttribute('aria-expanded') === 'true';
        const newState = !isExpanded;
        
        // Actualizar estados de accesibilidad
        menuButton.setAttribute('aria-expanded', String(newState));
        dropdownMenu.setAttribute('aria-hidden', String(!newState));
        dropdownOverlay.setAttribute('aria-hidden', String(!newState));
        
        // Ocultar el botón del menú cuando se abre
        if (newState) {
            menuButton.style.opacity = '0';
            menuButton.style.visibility = 'hidden';
            
            // Enfocar el primer elemento del menú al abrirlo
            const firstMenuItem = dropdownMenu.querySelector('.dropdown-item, .close-menu');
            if (firstMenuItem) firstMenuItem.focus();
        } else {
            // Restaurar el botón del menú al cerrar
            menuButton.style.opacity = '1';
            menuButton.style.visibility = 'visible';
            menuButton.focus();
        }
    }
    
    // Función para cerrar el menú
    function closeMenu() {
        if (!menuButton || !dropdownMenu || !dropdownOverlay) return;
        
        menuButton.setAttribute('aria-expanded', 'false');
        dropdownMenu.setAttribute('aria-hidden', 'true');
        dropdownOverlay.setAttribute('aria-hidden', 'true');
        
        // Restaurar el botón del menú
        menuButton.style.opacity = '1';
        menuButton.style.visibility = 'visible';
        menuButton.focus();
    }
    
    // Inicializar elementos del menú
    const dropdownOverlay = document.getElementById('dropdown-overlay');
    const closeMenuButton = document.querySelector('.close-menu');
    
    // Manejar clic en el botón del menú
    if (menuButton) {
        menuButton.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMenu();
        });
    }
    
    // Manejar clic en el botón de cerrar menú
    if (closeMenuButton) {
        closeMenuButton.addEventListener('click', (e) => {
            e.preventDefault();
            closeMenu();
        });
    }
    
    // Cerrar al hacer clic en el overlay
    if (dropdownOverlay) {
        dropdownOverlay.addEventListener('click', closeMenu);
    }
    
    // Cerrar con la tecla Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && menuButton && menuButton.getAttribute('aria-expanded') === 'true') {
            e.preventDefault();
            closeMenu();
        }
    });
    
    // Manejar clics en los elementos del menú
    document.addEventListener('click', (e) => {
        const menuItem = e.target.closest('.dropdown-item');
        if (menuItem) {
            e.preventDefault();
            const action = menuItem.getAttribute('data-action');
            console.log('Menú seleccionado:', action);
            
            // Cerrar el menú después de la selección
            closeMenu();
            
            // Aquí puedes agregar la lógica para cada acción del menú
            switch(action) {
                case 'upload-material':
                    showUploadModal();
                    break;
                case 'upload-photo':
                    alert('Función de subir foto en desarrollo');
                    break;
                case 'my-data':
                    alert('Función de mis datos en desarrollo');
                    break;
                case 'logout':
                    handleLogout();
                    break;
            }
        }
    });
    
    // Función para mostrar el modal de carga (placeholder)
    function showUploadModal() {
        alert('Función de subir material en desarrollo');
    }
    
    // Manejadores de eventos para los elementos del menú usando delegación
    document.addEventListener('click', (e) => {
        const menuItem = e.target.closest('[data-action]');
        if (!menuItem) return;
        
        e.preventDefault();
        const action = menuItem.getAttribute('data-action');
        
        switch(action) {
            case 'upload-material':
                console.log('Subir material');
                showUploadModal();
                break;
            case 'upload-photo':
                console.log('Subir foto');
                alert('Función de subir foto en desarrollo');
                break;
            case 'my-data':
                console.log('Ver mis datos');
                alert('Función de mis datos en desarrollo');
                break;
            case 'logout':
                console.log('Cerrar sesión');
                handleLogout();
                break;
        }
        
        closeMenu();
    });
    
    // Enviar mensaje al hacer submit
    if (messageForm) {
        messageForm.addEventListener('submit', (e) => {
            e.preventDefault();
            sendMessage();
        });
    }
    
    // Enviar mensaje al hacer clic en el botón
    if (sendButton) {
        sendButton.addEventListener('click', sendMessage);
    }
    
    // Controlar los botones de grabación de audio
    // Los event listeners ya están configurados en initializeDOMElements
    
    // Alternar tema
    if (themeToggle) {
        themeToggle.addEventListener('click', toggleTheme);
    }
    
    // Permitir enviar mensaje con Shift+Enter para saltar línea
    if (messageInput) {
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
    }
}

// Añadir un mensaje al chat
function addMessage(role, content, timestamp = null, messageId = null) {
    console.log(`Añadiendo mensaje - Rol: ${role}, Contenido:`, content);
    
    // Asegurarse de que el contenedor de mensajes exista
    if (!messagesContainer) {
        console.error('El contenedor de mensajes no está disponible, intentando recuperarlo...');
        messagesContainer = document.getElementById('messages');
        if (!messagesContainer) {
            console.error('No se pudo encontrar el contenedor de mensajes');
            return null;
        }
    }

    // Si es un mensaje del asistente, asegurarse de que el indicador de escritura se oculte primero
    if (role === 'assistant') {
        hideTypingIndicator();
    }

    // Crear elemento de mensaje
    const messageElement = document.createElement('div');
    messageElement.className = `message message-${role}`;
    
    // Si se proporciona un ID, asignarlo al mensaje
    if (messageId) {
        messageElement.id = messageId;
    }
    
    // Asegurarse de que tengamos una fecha válida
    const messageDate = timestamp ? new Date(timestamp) : new Date();
    
    // Formatear la hora
    let timeString = '';
    try {
        timeString = messageDate.toLocaleTimeString('es-ES', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
    } catch (e) {
        console.error('Error al formatear la hora:', e);
        timeString = new Date().toLocaleTimeString('es-ES', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
    }
    
    // Crear contenedor de contenido de forma segura
    const contentContainer = document.createElement('div');
    contentContainer.className = 'message-content';
    
    // Si el contenido es HTML, usamos innerHTML, de lo contrario textContent
    if (content && typeof content === 'string' && content.includes('<') && content.includes('>')) {
        // Si parece contener HTML, lo añadimos directamente
        contentContainer.innerHTML = content;
    } else if (content !== null && content !== undefined) {
        // Si es texto plano, usamos textContent para seguridad
        contentContainer.textContent = content;
    } else {
        // Si el contenido es nulo o indefinido, establecer un valor predeterminado
        contentContainer.textContent = '';
    }
    
    // Crear elemento de tiempo
    const timeElement = document.createElement('div');
    timeElement.className = 'message-time';
    timeElement.textContent = timeString;
    
    // Añadir elementos al mensaje
    messageElement.appendChild(contentContainer);
    messageElement.appendChild(timeElement);
    
    // Asegurarse de que el mensaje sea visible
    messageElement.style.opacity = '0';
    messageElement.style.transition = 'opacity 0.3s ease, margin-top 0.2s ease';
    
    // Añadir mensaje al contenedor
    messagesContainer.appendChild(messageElement);
    
    // Forzar un reflow para asegurar que la animación funcione
    void messageElement.offsetHeight;
    
    // Hacer visible el mensaje con animación
    messageElement.style.opacity = '1';
    
    console.log('Mensaje añadido al DOM:', { role, content });
    
    // Desplazarse al final de los mensajes con un pequeño retraso
    // para asegurar que el DOM se haya actualizado
    setTimeout(() => {
        // Asegurarse de que el mensaje esté completamente visible
        messageElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        scrollToBottom();
    }, 10);
    
    // Guardar mensaje en el almacenamiento local
    if (content !== null && content !== undefined) {
        saveMessage(role, content, messageDate);
    }
    
    return messageElement;
}

// Mostrar indicador de escritura
function showTypingIndicator() {
    // Primero verificar si ya existe un indicador
    const existingIndicator = document.getElementById('typing-indicator');
    if (existingIndicator) {
        // Si ya existe, asegurarse de que esté visible
        existingIndicator.setAttribute('aria-hidden', 'false');
        return;
    }
    
    // Crear el elemento del indicador
    const typingElement = document.createElement('div');
    typingElement.className = 'typing-indicator';
    typingElement.id = 'typing-indicator';
    typingElement.setAttribute('aria-label', 'El asistente está escribiendo...');
    typingElement.setAttribute('aria-hidden', 'false');
    typingElement.setAttribute('role', 'status');
    
    // Crear los puntos de la animación
    typingElement.innerHTML = `
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <div class="typing-dot"></div>
        <span class="sr-only">El asistente está escribiendo...</span>
    `;
    
    // Asegurarse de que el contenedor de mensajes existe
    if (messagesContainer) {
        // Añadir el indicador al contenedor
        messagesContainer.appendChild(typingElement);
        
        // Desplazarse al final después de un breve retraso para permitir que se renderice
        setTimeout(() => {
            scrollToBottom();
            
            // Forzar un reflow para asegurar que la animación se ejecute
            void typingElement.offsetWidth;
            
            // Aplicar la clase de animación
            typingElement.setAttribute('aria-hidden', 'false');
        }, 10);
    } else {
        console.error('No se pudo encontrar el contenedor de mensajes');
    }
}

// Ocultar indicador de escritura
function hideTypingIndicator() {
    const typingElement = document.getElementById('typing-indicator');
    if (!typingElement) return;
    
    // Iniciar la transición de salida
    typingElement.setAttribute('aria-hidden', 'true');
    
    // Esperar a que termine la transición antes de eliminar el elemento
    const onTransitionEnd = () => {
        typingElement.removeEventListener('transitionend', onTransitionEnd);
        if (typingElement && typingElement.parentNode) {
            typingElement.remove();
        }
    };
    
    typingElement.addEventListener('transitionend', onTransitionEnd);
    
    // Como respaldo, eliminar después de un tiempo razonable
    setTimeout(() => {
        if (typingElement && typingElement.parentNode) {
            typingElement.removeEventListener('transitionend', onTransitionEnd);
            typingElement.remove();
        }
    }, 500); // Tiempo máximo de espera
}

// Función para procesar el mensaje (llamada separada para mejor manejo de async/await)
async function processMessage(userMessage) {
    try {
        // Mostrar indicador de escritura
        showTypingIndicator();
        
        // Usar 'Marcelo' como user_id fijo
        const userId = 'Marcelo';
        
        // Datos a enviar
        const messageData = {
            user_id: userId,
            message: userMessage
        };
        
        console.log('Enviando mensaje como usuario:', userId);

        // URL de la API
        const apiUrl = 'https://grupodos.app.n8n.cloud/webhook/chat';
        console.log('Enviando solicitud a:', apiUrl);

        // Convertir a form-urlencoded
        const body = new URLSearchParams();
        Object.entries(messageData).forEach(([k, v]) => body.append(k, v));

        // Enviar petición
        console.log('Enviando petición al servidor...');
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body
        });

        console.log('Respuesta recibida, estado:', response.status);

        // Verificar respuesta
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Error en la respuesta del servidor:', errorText);
            throw new Error(`Error HTTP: ${response.status} - ${errorText}`);
        }

        // Procesar respuesta
        let result = {};
        const responseData = await response.text();
        console.log('Respuesta en texto plano:', responseData);
        
        try {
            // Intentar parsear como JSON
            result = JSON.parse(responseData);
            console.log('Respuesta parseada como JSON:', result);
        } catch (e) {
            console.log('La respuesta no es JSON válido, se tratará como texto plano');
            result = { response: responseData };
        }

        console.log('Respuesta del servidor procesada:', result);

        // Obtener el texto de respuesta
        let responseText = '';
        
        // Intentar obtener el mensaje de diferentes posibles formatos de respuesta
        if (result.output) {
            responseText = result.output;
        } else if (result.response) {
            responseText = result.response;
        } else if (result.message) {
            responseText = result.message;
        } else if (result.text) {
            responseText = result.text;
        } else if (typeof result === 'string') {
            responseText = result;
        } else {
            responseText = 'He recibido tu mensaje. ¿En qué más puedo ayudarte?';
        }
        
        // Asegurarse de que el indicador de escritura se oculte
        hideTypingIndicator();
        
        // Pequeña pausa para asegurar que el indicador se oculte antes de mostrar la respuesta
        setTimeout(() => {
            // Añadir la respuesta al chat
            addMessage('assistant', responseText);
        }, 50);
        
    } catch (error) {
        console.error('Error al procesar el mensaje:', error);
        hideTypingIndicator();
        addMessage('assistant', 'Lo siento, hubo un error al procesar tu solicitud. Por favor, inténtalo de nuevo.');
    }
}

// Función para enviar mensajes
function sendMessage(userMessage = null) {
    console.log('Iniciando función sendMessage');
    
    try {
        // Si no se proporciona un mensaje, obtenerlo del campo de entrada
        if (userMessage === null) {
            if (!messageInput) {
                console.error('messageInput no está definido');
                messageInput = document.getElementById('message-input');
                if (!messageInput) {
                    console.error('No se pudo encontrar el campo de entrada de mensaje');
                    return;
                }
            }
            
            userMessage = messageInput.value.trim();
            console.log('Mensaje a enviar:', userMessage);
            
            if (!userMessage) {
                console.log('El mensaje está vacío, no se envía');
                return;
            }
            
            // Mostrar mensaje del usuario y limpiar el campo de entrada
            addMessage('user', userMessage);
            messageInput.value = '';
            
            // Desplazarse al final después de agregar el mensaje
            setTimeout(() => {
                scrollToBottom();
                
                // Pequeña pausa para asegurar que el mensaje se muestre
                setTimeout(() => {
                    // Procesar el mensaje
                    processMessage(userMessage);
                }, 100);
                
            }, 50);
        } else {
            // Si ya se proporcionó un mensaje, simplemente procesarlo
            processMessage(userMessage);
        }
        
    } catch (error) {
        console.error('Error al enviar el mensaje:', error);
        hideTypingIndicator();
        addMessage('assistant', 'Lo siento, hubo un error al procesar tu solicitud. Por favor, inténtalo de nuevo.');
    }
}
        
        // Datos a enviar
        const messageData = {
            user_id: userId,
            message: userMessage
        };
        
        console.log('Enviando mensaje como usuario:', userId);

        // URL de la API
        const apiUrl = 'https://grupodos.app.n8n.cloud/webhook/chat';
        console.log('Enviando solicitud a:', apiUrl);

        // Convertir a form-urlencoded
        const body = new URLSearchParams();
        Object.entries(messageData).forEach(([k, v]) => body.append(k, v));

        // Enviar petición
        console.log('Enviando petición al servidor...');
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body
        });

        console.log('Respuesta recibida, estado:', response.status);

        // Verificar respuesta
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Error en la respuesta del servidor:', errorText);
            throw new Error(`Error HTTP: ${response.status} - ${errorText}`);
        }

        // Procesar respuesta
        let result = {};
        const responseData = await response.text();
        console.log('Respuesta en texto plano:', responseData);
        
        try {
            // Intentar parsear como JSON
            result = JSON.parse(responseData);
            console.log('Respuesta parseada como JSON:', result);
        } catch (e) {
            console.log('La respuesta no es JSON válido, se tratará como texto plano');
            result = { response: responseData };
        }

        console.log('Respuesta del servidor procesada:', result);

        // Mostrar respuesta al usuario
        let responseText = '';
        
        // Intentar obtener el mensaje de diferentes posibles formatos de respuesta
        if (result.output) {
            responseText = result.output;
        } else if (result.response) {
            responseText = result.response;
        } else if (result.message) {
            responseText = result.message;
        } else if (result.text) {
            responseText = result.text;
        } else if (typeof result === 'string') {
            responseText = result;
        } else {
            responseText = 'He recibido tu mensaje. ¿En qué más puedo ayudarte?';
        }
        
        // Añadir la respuesta al chat
        addMessage('assistant', responseText);

    } catch (error) {
        console.error('Error al enviar el mensaje:', error);
        addMessage('assistant', 'Lo siento, hubo un error al procesar tu solicitud. Por favor, inténtalo de nuevo.');
    } finally {
        // Ocultar indicador de escritura en cualquier caso
        hideTypingIndicator();
    }
}

// Función para manejar la grabación de audio
async function handleRecordedAudio(transcript) {
    try {
        console.log('Mensaje de voz transcrito:', transcript);
        if (!transcript || transcript.trim() === '') {
            console.log('Transcripción vacía, ignorando...');
            return;
        }
        
        const messageId = 'user-msg-' + Date.now();
        addMessage('user', transcript, null, messageId);
        
        console.log('Enviando mensaje de voz al servidor...');
        // Usar un pequeño retraso para asegurar que la interfaz se actualice
        setTimeout(async () => {
            try {
                await sendMessage(transcript);
                console.log('Mensaje de voz enviado correctamente');
            } catch (error) {
                console.error('Error al enviar mensaje de voz:', error);
                addMessage('assistant', 'Hubo un error al enviar tu mensaje de voz. Por favor, inténtalo de nuevo.');
            }
        }, 100);
        
    } catch (error) {
        console.error('Error al procesar el audio:', error);
        addMessage('assistant', 'No se pudo procesar tu mensaje de voz. Por favor, inténtalo de nuevo.');
    } finally {
        // Asegurarse de que la interfaz se actualice incluso si hay un error
        updateRecordingUI(false);
    }
}

// Alternar reconocimiento de voz
function toggleVoiceRecognition() {
    isListening ? stopVoiceRecognition() : startVoiceRecognition();
}

// Alternar entre temas claro y oscuro
function toggleTheme() {
    isDarkMode = !isDarkMode;
    updateTheme();
    localStorage.setItem('darkMode', isDarkMode);
}

// Actualizar el tema según el estado actual
function updateTheme() {
    document.body.classList.toggle('dark-theme', isDarkMode);
    themeToggle.innerHTML = isDarkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
}

// Desplazarse al final de los mensajes
function scrollToBottom() {
    console.log('Ejecutando scrollToBottom');
    
    if (!messagesContainer) {
        console.error('El contenedor de mensajes no está disponible');
        messagesContainer = document.getElementById('messages');
        if (!messagesContainer) {
            console.error('No se pudo encontrar el contenedor de mensajes');
            return;
        }
    }
    
    // Usar requestAnimationFrame para asegurar que el DOM esté actualizado
    requestAnimationFrame(() => {
        try {
            console.log('Intentando desplazamiento...');
            
            // Método 1: Usar scrollTo con comportamiento suave
            messagesContainer.scrollTo({
                top: messagesContainer.scrollHeight,
                behavior: 'smooth'
            });
            
            // Método 2: Establecer scrollTop directamente como respaldo
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Forzar un segundo intento después de un pequeño retraso
            setTimeout(() => {
                if (messagesContainer) {
                    console.log('Segundo intento de desplazamiento');
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // Tercer intento con scrollIntoView en el último mensaje
                    const lastMessage = messagesContainer.lastElementChild;
                    if (lastMessage) {
                        console.log('Tercer intento con scrollIntoView');
                        lastMessage.scrollIntoView({
                            behavior: 'auto',
                            block: 'end',
                            inline: 'nearest'
                        });
                    }
                    
                    // Cuarto intento con scrollTo sin animación
                    setTimeout(() => {
                        if (messagesContainer) {
                            console.log('Cuarto intento con scrollTo sin animación');
                            messagesContainer.scrollTo(0, messagesContainer.scrollHeight);
                        }
                    }, 50);
                }
            }, 50);
            
            console.log('Desplazamiento completado');
            
        } catch (error) {
            console.error('Error en scrollToBottom:', error);
            
            // Método de respaldo en caso de error
            try {
                if (messagesContainer) {
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                }
            } catch (e) {
                console.error('Error en el método de respaldo de desplazamiento:', e);
            }
        }
    });
    
    // Asegurarse de que el contenedor de mensajes tenga la altura correcta
    if (messagesContainer) {
        messagesContainer.style.minHeight = '100%';
    }
}

// Guardar mensaje en el almacenamiento local
function saveMessage(role, content, timestamp) {
    const messages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
    messages.push({ role, content, timestamp: timestamp.toISOString() });
    
    // Mantener solo los últimos 100 mensajes para no llenar el almacenamiento local
    if (messages.length > 100) {
        messages.shift();
    }
    
    localStorage.setItem('chatMessages', JSON.stringify(messages));
}

// Cargar mensajes guardados
function loadMessages() {
    const savedMessages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
    
    savedMessages.forEach(msg => {
        addMessage(msg.role, msg.content, new Date(msg.timestamp));
    });
}

// Función para mostrar el modal de carga de archivos
function showUploadModal() {
    console.log('Intentando mostrar el modal de carga...');
    
    if (!uploadModal) {
        console.error('Error: No se encontró el elemento del modal (uploadModal)');
        return;
    }
    
    console.log('Mostrando modal de carga...');
    uploadModal.classList.add('show');
    document.body.style.overflow = 'hidden';
    
    // Forzar el foco en el modal para accesibilidad
    uploadModal.setAttribute('aria-hidden', 'false');
    
    // Reiniciar la interfaz de usuario
    resetFileUploadUI();
    
    // Hacer que el modal sea enfocable
    uploadModal.tabIndex = -1;
    uploadModal.focus();
    
    console.log('Modal de carga mostrado');
}

// Función para ocultar el modal de carga de archivos
function hideUploadModal() {
    if (uploadModal) {
        uploadModal.classList.remove('show');
        document.body.style.overflow = '';
    }
}

// Función para reiniciar la interfaz de carga de archivos
function resetFileUploadUI() {
    if (fileInfo) fileInfo.innerHTML = '';
    if (progressBar) progressBar.style.width = '0%';
    if (progressText) progressText.textContent = '0%';
    if (uploadProgress) uploadProgress.style.display = 'none';
    if (confirmUpload) confirmUpload.disabled = true;
    if (fileSelector) fileSelector.value = '';
    
    // Mostrar el mensaje inicial nuevamente
    const fileUploadContent = document.querySelector('.file-upload-content');
    if (fileUploadContent) {
        const initialMessage = fileUploadContent.querySelector('p');
        if (initialMessage) initialMessage.style.display = 'block';
    }
}

// Función para manejar la selección de archivos
function handleFileSelect(event) {
    event.preventDefault();
    event.stopPropagation();

    const files = event.target.files || (event.dataTransfer ? event.dataTransfer.files : []);
    if (files.length > 0) {
        updateFileInfo(files[0]);
    }
}

// Función para actualizar la información del archivo seleccionado
function updateFileInfo(file) {
    if (!file) return;

    const fileSize = (file.size / (1024 * 1024)).toFixed(2); // Convertir a MB
    const fileType = file.name.split('.').pop().toUpperCase();
    
    // Ocultar el mensaje inicial
    const fileUploadContent = document.querySelector('.file-upload-content');
    if (fileUploadContent) {
        const initialMessage = fileUploadContent.querySelector('p');
        if (initialMessage) initialMessage.style.display = 'none';
    }

    fileInfo.innerHTML = `
        <div class="file-preview">
            <i class="fas fa-file-alt"></i>
            <div class="file-details">
                <span class="file-name">${file.name}</span>
                <span class="file-meta">${fileType} • ${fileSize} MB</span>
            </div>
            <button type="button" class="remove-file" title="Eliminar archivo">
                <i class="fas fa-times"></i>
            </button>
        </div>
    `;

    // Habilitar el botón de confirmación
    if (confirmUpload) confirmUpload.disabled = false;

    // Agregar evento al botón de eliminar
    const removeBtn = fileInfo.querySelector('.remove-file');
    if (removeBtn) {
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            resetFileUploadUI();
            if (fileSelector) fileSelector.value = '';
        });
    }
}

// Función para manejar el arrastrar y soltar archivos
function setupDragAndDrop() {
    if (!dropArea) return;

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, () => {
            dropArea.classList.add('drag-over');
        });
    });

    ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, () => {
            dropArea.classList.remove('drag-over');
        });
    });

    dropArea.addEventListener('drop', handleDrop);

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
            updateFileInfo(files[0]);
            // Actualizar el input file para que tenga el archivo seleccionado
            if (fileSelector) {
                fileSelector.files = files;
            }
        }
    }
}

// Función para subir el archivo al servidor
async function uploadFile() {
    if (!fileSelector || !fileSelector.files || fileSelector.files.length === 0) {
        alert('Por favor, selecciona un archivo primero.');
        return;
    }

    const file = fileSelector.files[0];
    
    // Crear objeto con los datos a enviar
    const messageData = {
        username: currentUser ? currentUser.name : 'usuario_anonimo',
        message: `Nuevo archivo subido: ${file.name}`,
        fileName: file.name,
        fileType: file.type,
        fileSize: file.size
    };

    try {
        // Mostrar la barra de progreso
        if (uploadProgress) uploadProgress.style.display = 'block';
        if (confirmUpload) confirmUpload.disabled = true;

        // Simular progreso de carga
        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += 10;
            if (progress > 90) clearInterval(progressInterval);
            if (progressBar) progressBar.style.width = `${progress}%`;
            if (progressText) progressText.textContent = `${progress}%`;
        }, 100);

        // Enviar datos al endpoint de n8n
        const response = await fetch('https://grupodos.app.n8n.cloud/webhook-test/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(messageData)
        });

        // Completar la barra de progreso
        clearInterval(progressInterval);
        if (progressBar) progressBar.style.width = '100%';
        if (progressText) progressText.textContent = '100%';

        if (!response.ok) {
            let errorMessage = 'Error al subir el archivo';
            try {
                const errorData = await response.json();
                errorMessage = errorData.message || errorMessage;
            } catch (e) {
                errorMessage = `Error ${response.status}: ${response.statusText}`;
            }
            throw new Error(errorMessage);
        }

        const result = await response.json();
        console.log('Respuesta del servidor:', result);

        // Guardar información del archivo subido
        if (!uploadedFiles) uploadedFiles = [];
        uploadedFiles.push({
            name: file.name,
            type: file.type,
            size: file.size,
            uploadedAt: new Date().toISOString(),
            status: 'subido'
        });

        // Mostrar la respuesta del servidor en el chat
        if (result.response) {
            // Si hay una respuesta del servidor, mostrarla
            addMessage('assistant', result.response);
        } else if (result.message) {
            // Si hay un mensaje de confirmación, mostrarlo
            addMessage('assistant', result.message);
        } else {
            // Mensaje por defecto si no hay respuesta específica
            addMessage('assistant', `He recibido tu archivo "${file.name}" y lo estoy procesando. ¿En qué puedo ayudarte con él?`);
        }

        // Cerrar el modal después de un breve retraso
        setTimeout(() => {
            hideUploadModal();
        }, 1000);

    } catch (error) {
        console.error('Error al subir el archivo:', error);
        alert(`Error al subir el archivo: ${error.message}`);

        // Reiniciar la interfaz en caso de error
        resetFileUploadUI();
        if (confirmUpload) confirmUpload.disabled = false;
    }
}

// Configurar los event listeners para la carga de archivos
function setupFileUploadListeners() {
    console.log('Iniciando configuración de listeners de carga de archivos...');
    
    if (!uploadButton) {
        console.error('Error: No se encontró el botón de carga (uploadButton)');
    } else {
        console.log('Añadiendo evento click al botón de carga...');
        uploadButton.addEventListener('click', function(e) {
            console.log('Botón de carga clickeado');
            showUploadModal();
        });
    }

    // Cerrar el modal al hacer clic en la X
    if (closeModal) {
        console.log('Añadiendo evento click al botón de cerrar...');
        closeModal.addEventListener('click', function() {
            console.log('Botón cerrar clickeado');
            hideUploadModal();
        });
    } else {
        console.error('Error: No se encontró el botón de cerrar (closeModal)');
    }

    // Cerrar el modal al hacer clic en cancelar
    if (cancelUpload) {
        console.log('Añadiendo evento click al botón de cancelar...');
        cancelUpload.addEventListener('click', function() {
            console.log('Botón cancelar clickeado');
            hideUploadModal();
        });
    } else {
        console.error('Error: No se encontró el botón de cancelar (cancelUpload)');
    }

    // Cerrar el modal al hacer clic fuera del contenido
    window.addEventListener('click', function(e) {
        if (e.target === uploadModal) {
            console.log('Clic fuera del modal, cerrando...');
            hideUploadModal();
        }
    });

    // Verificar si el selector de archivos está disponible
    if (!fileSelector) {
        console.error('Error: No se encontró el selector de archivos (fileSelector)');
    } else {
        console.log('Añadiendo evento change al selector de archivos...');
        fileSelector.addEventListener('change', function(e) {
            console.log('Archivo seleccionado:', e.target.files[0]?.name || 'ninguno');
            handleFileSelect(e);
        });
        
        // Añadir manejador de clic al texto "haz clic para seleccionar"
        const browseFiles = document.querySelector('.browse-files');
        if (browseFiles) {
            console.log('Añadiendo evento click al texto de selección de archivos...');
            browseFiles.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Texto de selección de archivos clickeado');
                fileSelector.click();
            });
        } else {
            console.error('Error: No se encontró el elemento .browse-files');
        }
        
        // También hacer que toda el área de carga sea clickeable
        const fileUploadContent = document.querySelector('.file-upload-content');
        if (fileUploadContent) {
            console.log('Añadiendo evento click al área de carga...');
            fileUploadContent.addEventListener('click', function(e) {
                // Solo activar el selector de archivos si no se hizo clic en un botón u otro elemento interactivo
                if (e.target === fileUploadContent || e.target.tagName === 'P' || e.target.tagName === 'I') {
                    console.log('Área de carga clickeada');
                    fileSelector.click();
                }
            });
        }
    }

    // Configurar arrastrar y soltar si el área está disponible
    if (!dropArea) {
        console.error('Error: No se encontró el área de arrastrar y soltar (dropArea)');
    } else {
        console.log('Configurando arrastrar y soltar...');
        setupDragAndDrop();
    }

    // Configurar el botón de confirmar si está disponible
    if (!confirmUpload) {
        console.error('Error: No se encontró el botón de confirmar (confirmUpload)');
    } else {
        console.log('Añadiendo evento click al botón de confirmar...');
        confirmUpload.addEventListener('click', function() {
            console.log('Botón confirmar clickeado');
            uploadFile();
        });
    }
    
    console.log('Configuración de listeners de carga de archivos completada');
}

// Función para manejar la selección de tipo de usuario
function handleUserTypeSelect(type) {
    console.log(`Tipo de usuario seleccionado: ${type}`);
    userType = type;
    hideUserTypeScreen();
    showAuthScreen();
}

// Función para iniciar la entrevista
function startInterview() {
    console.log('Iniciando entrevista...');
    
    // Ocultar todas las pantallas
    hideAllScreens();
    
    // Mostrar pantalla de entrevista
    if (interviewScreen) {
        interviewScreen.classList.remove('hidden');
        
        // Enfocar el primer campo
        const firstInput = document.querySelector('#interview-form input, #interview-form select, #interview-form textarea');
        if (firstInput) {
            firstInput.focus();
        }
    }
    
    // Configurar el manejador del formulario de entrevista
    const interviewForm = document.getElementById('interview-form');
    if (interviewForm) {
        interviewForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // Obtener los datos del formulario
            const formData = new FormData(interviewForm);
            const interviewData = {};
            
            // Convertir FormData a objeto
            for (let [key, value] of formData.entries()) {
                interviewData[key] = value.trim();
            }
            
            try {
                // Mostrar indicador de carga
                const submitButton = interviewForm.querySelector('button[type="submit"]');
                const originalButtonText = submitButton.innerHTML;
                submitButton.disabled = true;
                submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Guardando...';
                
                // Simular un retraso para la operación asíncrona
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Obtener el usuario actual
                const currentUser = JSON.parse(localStorage.getItem('currentUser')) || {};
                console.log('Usuario actual en localStorage (antes de actualizar):', currentUser);
                
                // Actualizar los datos del usuario con las respuestas de la entrevista
                const updatedUser = {
                    ...currentUser,
                    ...interviewData,
                    hasCompletedInterview: true,
                    interviewCompletedAt: new Date().toISOString(),
                    // Asegurarse de que el ID del usuario esté presente
                    id: currentUser.id || Date.now().toString()
                };
                
                // Guardar los datos actualizados
                try {
                    localStorage.setItem('currentUser', JSON.stringify(updatedUser));
                    console.log('Datos guardados en localStorage:', updatedUser);
                    
                    // Verificar que los datos se guardaron correctamente
                    const storedUser = JSON.parse(localStorage.getItem('currentUser'));
                    console.log('Datos leídos de localStorage (después de guardar):', storedUser);
                    
                    // Mostrar un mensaje de éxito
                    alert('¡Tus respuestas se han guardado correctamente!');
                    
                    // Redirigir a la pantalla principal
                    window.location.href = 'index.html';
                } catch (error) {
                    console.error('Error al guardar en localStorage:', error);
                    alert('Hubo un error al guardar tus respuestas. Por favor, inténtalo de nuevo.');
                    throw error; // Relanzar el error para que sea manejado por el catch externo
                }
                
            } catch (error) {
                console.error('Error al guardar la entrevista:', error);
                alert('Ocurrió un error al guardar tus respuestas. Por favor, inténtalo de nuevo.');
                submitButton.disabled = false;
                submitButton.innerHTML = originalButtonText;
            }
        });
    }
}

// Función para manejar las respuestas de la entrevista
async function handleInterviewAnswer(answer) {
    if (!answer) return;
    
    // Guardar la respuesta
    interviewAnswers.push(answer);
    
    // Mostrar la respuesta del usuario
    addInterviewMessage('user', answer);
    
    // Limpiar el input
    if (interviewAnswer) {
        interviewAnswer.value = '';
    }
    
    // Verificar si hay más preguntas
    if (currentInterviewStep < interviewQuestions.length - 1) {
        currentInterviewStep++;
        
        // Mostrar la siguiente pregunta después de un breve retraso
        setTimeout(() => {
            addInterviewMessage('assistant', interviewQuestions[currentInterviewStep]);
        }, 800);
    } else {
        // Entrevista completada
        setTimeout(() => {
            // Mostrar pantalla de finalización
            const interviewForm = document.getElementById('interview-form');
            const interviewComplete = document.getElementById('interview-complete');
            
            if (interviewForm) interviewForm.classList.add('hidden');
            if (interviewComplete) interviewComplete.classList.remove('hidden');
            
            // Guardar respuestas en el almacenamiento local
            const userData = JSON.parse(localStorage.getItem('currentUser') || '{}');
            userData.interviewAnswers = interviewAnswers;
            localStorage.setItem('currentUser', JSON.stringify(userData));
            
            // Marcar como usuario existente
            localStorage.setItem('newUser', 'false');
            
            // Enviar respuestas al backend
            sendInterviewAnswers(userData);
        }, 1000);
    }
}

// Función para enviar las respuestas de la entrevista al backend
async function sendInterviewAnswers(userData) {
    try {
        const response = await fetch('https://grupodos.app.n8n.cloud/webhook-test/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                type: 'interview_answers',
                userId: userData.id || 'anonymous',
                email: userData.email || '',
                answers: interviewAnswers
            })
        });
        
        if (!response.ok) {
            throw new Error('Error al enviar las respuestas');
        }
        
        console.log('Respuestas de la entrevista guardadas exitosamente');
    } catch (error) {
        console.error('Error al enviar las respuestas:', error);
    }
}

// Función para añadir mensajes a la entrevista
function addInterviewMessage(role, content) {
    if (!interviewMessages) return;
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${role}`;
    messageDiv.innerHTML = `
        <div class="message-content">
            <p>${content}</p>
        </div>
    `;
    interviewMessages.appendChild(messageDiv);
    scrollInterviewToBottom();
}

// Función para desplazarse al final de los mensajes de la entrevista
function scrollInterviewToBottom() {
    if (interviewMessages) {
        interviewMessages.scrollTop = interviewMessages.scrollHeight;
    }
}

// Ocultar todas las pantallas
function hideAllScreens() {
    const screens = [splashScreen, userTypeScreen, authScreen, registerScreen, interviewScreen, appContainer];
    screens.forEach(screen => {
        if (screen) screen.classList.add('hidden');
    });
}

// Inicializar la aplicación cuando el DOM esté listo
function startApplication() {
    try {
        console.log('Iniciando aplicación...');
        init();
    } catch (error) {
        console.error('Error al iniciar la aplicación:', error);
        // Mostrar un mensaje de error en la interfaz
        const errorDiv = document.createElement('div');
        errorDiv.style.position = 'fixed';
        errorDiv.style.top = '0';
        errorDiv.style.left = '0';
        errorDiv.style.width = '100%';
        errorDiv.style.padding = '20px';
        errorDiv.style.backgroundColor = '#fee2e2';
        errorDiv.style.color = '#b91c1c';
        errorDiv.style.textAlign = 'center';
        errorDiv.style.zIndex = '9999';
        errorDiv.textContent = 'Error al cargar la aplicación. Por favor, recarga la página.';
        document.body.prepend(errorDiv);
    }
}

// Verificar el estado del documento
if (document.readyState === 'loading') {
    // El documento aún se está cargando, esperar al evento DOMContentLoaded
    document.addEventListener('DOMContentLoaded', startApplication);
} else {
    // El documento ya está listo, ejecutar inmediatamente
    startApplication();
}
